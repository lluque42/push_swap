<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Push Swap: 42&#39;s push_swap project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Push Swap<span id="projectnumber">&#160;2024-08-05</span>
   </div>
   <div id="projectbrief">Push_swap project for Campus 42</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">42's push_swap project </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> Luis Luque (lluque) - 2024</p>
<p >Message to other 42 students: DO NOT COPY, get inspired!</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Introduction</h1>
<p >From project's subject: </p><blockquote class="doxtable">
<p >&zwj;You have 2 stacks named a and b.</p><ul>
<li>At the beginning:<ul>
<li>The stack a contains a random amount of negative and/or positive numbers which cannot be duplicated.</li>
<li>The stack b is empty.</li>
</ul>
</li>
<li>The goal is to sort in ascending order numbers into stack a. To do so you have the following operations at your disposal:<ul>
<li><b>sa (swap a)</b>: Swap the first 2 elements at the top of stack a. Do nothing if there is only one or no elements.</li>
<li><b>sb (swap b)</b>: Swap the first 2 elements at the top of stack b. Do nothing if there is only one or no elements. ss : sa and sb at the same time.</li>
<li><b>pa (push a)</b>: Take the first element at the top of b and put it at the top of a. Do nothing if b is empty.</li>
<li><b>pb (push b)</b>: Take the first element at the top of a and put it at the top of b. Do nothing if a is empty.</li>
<li><b>ra (rotate a)</b>: Shift up all elements of stack a by 1. The first element becomes the last one.</li>
<li><b>rb (rotate b)</b>: Shift up all elements of stack b by 1. The first element becomes the last one.</li>
<li><b>rr</b>: ra and rb at the same time.</li>
<li><b>rra (reverse rotate a)</b>: Shift down all elements of stack a by 1. The last element becomes the first one.</li>
<li><b>rrb (reverse rotate b)</b>: Shift down all elements of stack b by 1. The last element becomes the first one.</li>
<li><b>rrr</b>: rra and rrb at the same time.. </li>
</ul>
</li>
</ul>
</blockquote>
<h1><a class="anchor" id="autotoc_md2"></a>
Directory tree</h1>
<pre class="fragment">./  
├── .gitignore              (to prevent undesired files to be stagged)  
├── Doxyfile                (doxygen config file for doc generation)  
├── Makefile                (use 'make help' for instructions)  
├── README.md               (brief documentation)  
├── doc/                    (documentation extracted from comments in .h)  
│   ├── html/               (html documentation)  
│   │   ├── ...  
│   │   ├── index.html      (entry point for html documentation)  
│   │   ├── ...  
│   └── man/                (man pages documentation)  
│       └── man3/  
│           └── ...         (example of use: 'man -l ft_string.h.3')  
├── include/                (directory for public header files (.h))  
│   ├── ...  
│   └── ...  
├── src/                    (dir for source code and private header files)  
│   ├── ...  
│   │   ├── ...                 
│   │   └── ...  
│   └── ...                 (may be structured in several directories)  
│       ├── ...  
│       └── ...  
├── lib/                    (external libraries)  
│   ├── ...  
│   └── libft               (each library in its own directory)  
├── bin/                    (directory for project's binaries and tester)  
│   ├── ...  
│   └── ...                 (may be structured in several directories)  
├── obj/                    (dir for source code and private header files)  
│   ├── ...  
│   │   ├── ...  
│   │   └── ...  
│   └── ...                 (structured as in ./src)  
│       ├── ...  
│       └── ...  
└── test/                   (test program src code)  
    ├── ...  
    ├── tester.c  
    └── ...  
</pre> <h1><a class="anchor" id="autotoc_md3"></a>
Compilation instructions</h1>
<p >Use ‘make help’ for instructions.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Data structures</h1>
<p >The main struct type of the program, where both stacks a and b are referenced as doubly linked circular lists. </p><div class="fragment"><div class="line">typedef struct s_ps_stacks</div>
<div class="line">{</div>
<div class="line">    t_dlclst    *a;</div>
<div class="line">    t_dlclst    *b;</div>
<div class="line">    int         left_to_pre_sort;</div>
<div class="line">}   t_ps_stacks;</div>
</div><!-- fragment --><p> The element struct type, where each of the numbers is storaged, along to its sorting metadata. The element type is that which is linked to the <em>content</em> member of the dlclst node. </p><div class="fragment"><div class="line">typedef struct s_element</div>
<div class="line">{</div>
<div class="line">    int     value;</div>
<div class="line">    int     pos_when_sorted;</div>
<div class="line">    int     pos_in_stack;</div>
<div class="line">    int     cost_a;</div>
<div class="line">    int     cost_b;</div>
<div class="line">}   t_element;</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md5"></a>
Layered implementation approach</h1>
<p >Very early in the design stage it became obvious that defining a few abstraction levels was the best approach to implement this project. From the lowest to the highest level, each level of abstraction builts on its immediate lower level. The main purpose of this was to keep the code legible while compartmentalizing: when working on (or at) a level, the details of the lower levels are ignore and only dealt with, indirectly, through the immediately lower level. In a nutshell, from lowest to highest:</p><ul>
<li>A collection of functions and structs data types to implement a doubly linked circular list (dlclst) was added to libft for this project. The choice for doubly linking responds to facilitate the swaping of nodes, while the circularity is ideal for the rotation of the nodes. The following image depicts an example dlclst list showing the links and directions: <div class="fragment"><div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
<div class="line">                                 _______________________________________</div>
<div class="line">   ^          prev (of my_list) |          _________________________    | </div>
<div class="line">   ^                            v         | next (of node5)         |   | </div>
<div class="line">   ^                               node5                            |   | </div>
<div class="line">   ^            prev (of node5) |         ^                         |   | </div>
<div class="line">next dir                        v         | next (of node4)         |   | </div>
<div class="line">                                   node4                            |   | </div>
<div class="line">                prev (of node4) |         ^                         |   | </div>
<div class="line">                                v         | next (of node3)         |   | </div>
<div class="line">                                   node3                            |   | </div>
<div class="line">                prev (of node3) |         ^                         |   | </div>
<div class="line">                                v         | next (of node2)         |   | </div>
<div class="line">                                   node2                            |   | </div>
<div class="line">                prev (of node2) |         ^                         |   | </div>
<div class="line">prev dir                        v         | next (of node my_list)  |   | </div>
<div class="line">   v        t_dlclst *my_list     my_list                           |   | </div>
<div class="line">   v                            |         ^ next (of node5)         |   | </div>
<div class="line">   v                            |         |_________________________|   | </div>
<div class="line">   v                            |_______________________________________| </div>
<div class="line">                                   prev (of my_list)</div>
<div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
</div><!-- fragment --></li>
<li>A collection of functions and data structures was developed using dlclst to implement the set of two stacks and every push-swap language instruction: <a class="el" href="ps__lang__instructions_8h.html#a90cfb0482953538059414c8b54f65045" title="pa – Pop b then push it to a.">pa()</a>, <a class="el" href="ps__lang__instructions_8h.html#ae0904d21a0d7b9954ad553bcd09a795e" title="pb – Pop a then push it to b.">pb()</a>, <a class="el" href="ps__lang__instructions_8h.html#a50b4be8011e99885e2d7803e46532986" title="sa – Swap a.">sa()</a>, <a class="el" href="ps__lang__instructions_8h.html#a86b5077e5a69e9889e2ef58981cb19e3" title="sb – Swap b.">sb()</a>, <a class="el" href="ps__lang__instructions_8h.html#a11c57edf21a78052370472d05a76471f" title="ss – Swap a and b at the same time.">ss()</a>, <a class="el" href="ps__lang__instructions_8h.html#afe65326d8932d0c80630c0f8ddb52e96" title="ra – Rotate a.">ra()</a>, <a class="el" href="ps__lang__instructions_8h.html#aa412e861fcd27fbef77966742690c908" title="rra – Reverse rotate a.">rra()</a>, <a class="el" href="ps__lang__instructions_8h.html#a5f34f231afdee32b940ce8e81f056010" title="rb – Rotate b.">rb()</a>, <a class="el" href="ps__lang__instructions_8h.html#abe160dcf9fba84d7d9a086768bd4e327" title="rrb – Reverse rotate b.">rrb()</a>, <a class="el" href="ps__lang__instructions_8h.html#adff333c60d5fd15fc029dd7f68d62ef6" title="rr – Rotate a and b at the same time.">rr()</a>, and <a class="el" href="ps__lang__instructions_8h.html#a1034f3139febeab7325d5e420ec3cccf" title="rrr – Reverse rotate a and b at the same time.">rrr()</a>. Also several functions were added to support peeking of elements, etc. The following image depicts an example of a stack showing the effects of every push-swap language instruction: <div class="fragment"><div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
<div class="line">          stack A                  stack B</div>
<div class="line">    ^        1  &gt;&gt;&gt;&gt;&gt;&gt;&gt; pa() &gt;&gt;&gt;&gt;&gt;&gt;&gt;                A sa() swaps the</div>
<div class="line">    ^        8    (from top to top)                    top and the</div>
<div class="line">ra(), rr()   3  (pb() does the same,                  second-to-top,</div>
<div class="line">direction    7    mutatis mutandi)                    that is, from:</div>
<div class="line">             2                                              1</div>
<div class="line">             6                                              8</div>
<div class="line">rra(), rrr() 4                                             ...</div>
<div class="line"> direction   0                                             to:</div>
<div class="line">    v        5                                              8</div>
<div class="line">    v        9                                              1</div>
<div class="line">                                                           ...</div>
<div class="line">                                                      sb() and ss()</div>
<div class="line">                                                      do the same,</div>
<div class="line">                                                     mutatis mutandi</div>
<div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
</div><!-- fragment --></li>
</ul>
<p >For clarity sake, let's put all the former information in an example.</p>
<p >This example will aid to clarify all the conventions in this implementation as well as helping while navigating (or, oh my God of course, while writing) the code.</p>
<p >When invoking the program as: </p><div class="fragment"><div class="line">                                                                            .</div>
<div class="line">bin/mandatory/push_swap 1 8 3 7 2 6 4 0 5 9</div>
<div class="line">                                                                            .</div>
</div><!-- fragment --><p> The arguments are read from left to right. Then, each argument, after validation, is <a class="el" href="ps__lang__init_8h.html#a86257d5443271bc31cb93358a304790d" title="bottom_pusha – Pushes an integer to the bottom of stack a.">bottom_pusha()</a>'ed into stack A. The <a class="el" href="ps__lang__init_8h.html#a86257d5443271bc31cb93358a304790d" title="bottom_pusha – Pushes an integer to the bottom of stack a.">bottom_pusha()</a> function ultimately uses ft_dlclst_insback() to place the node with the associated integer at the end of the dlclst that represents the stack A (the integer ends at the bottom of stack A). In this way, the first integer in the arguments lands on the top of stack A, while the last integer in the arguments lands on the bottom of stack A.</p>
<p >The following image shows the initial state of stack A with an example invocation of the program (notice de dlclst "next" and "prev" directions): </p><div class="fragment"><div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
<div class="line">                         Stack X</div>
<div class="line">                                       (get_value(ft_dlclst_last(ps-&gt;X))</div>
<div class="line">                  top of X    1 (0) &lt; first node in the respective dlclst</div>
<div class="line">  dlclst          top_1 of X  8 (1)</div>
<div class="line"> next dir                     3 (2)</div>
<div class="line">   v        ^                 7 (3)</div>
<div class="line">   v        ^                 2 (4)</div>
<div class="line">   v        ^                 6 (5)</div>
<div class="line">   v        ^                 4 (6)</div>
<div class="line">         dlclst               0 (7)</div>
<div class="line">        prev dir  bot_1 of X  5 (8)</div>
<div class="line">                  bottom of X 9 (9) &lt; last node in the respective dlclst </div>
<div class="line">                                           (get_value(ps-&gt;X))</div>
<div class="line">                                                                            .</div>
<div class="line">NOTE: Values in parenthesis are the respective element-&gt;pos_in_stack.</div>
<div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
</div><!-- fragment --><p >The top of each stack is the last node in the dlclst that implements it: </p><div class="fragment"><div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
<div class="line">$ bin/mandatory/push_swap 1 8 3 7 2 6 4 0 5 9</div>
<div class="line">                                                                            .</div>
<div class="line">         stack A                                         stack B</div>
<div class="line">                     (get_value(ft_dlclst_last(ps-&gt;a))</div>
<div class="line">top of A    1 (0) &lt; first node in the respective dlclst &gt;&gt;&gt;</div>
<div class="line">top_1 of A  8 (1)</div>
<div class="line">            3 (2)</div>
<div class="line">            7 (3)</div>
<div class="line">            2 (4)</div>
<div class="line">            6 (5)</div>
<div class="line">            4 (6)</div>
<div class="line">            0 (7)</div>
<div class="line">bot_1 of A  5 (8)</div>
<div class="line">bottom of A 9 (9) &lt; last node in the respective dlclst &gt;&gt;&gt; </div>
<div class="line">                         (get_value(ps-&gt;a))</div>
<div class="line">                                                                            .</div>
<div class="line">NOTE: Values in parenthesis are the respective element-&gt;pos_in_stack.</div>
<div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
</div><!-- fragment --><p> A pushing instruction moves one of the stack's top element to the other stack landing at the top position.</p>
<p >From the state of the stacks depicted in the image above, the following image shows the resulting state after performing five pushings to A (i.e. 5 x <a class="el" href="ps__lang__instructions_8h.html#a90cfb0482953538059414c8b54f65045" title="pa – Pop b then push it to a.">pa()</a>): </p><div class="fragment"><div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
<div class="line">         stack A                                         stack B</div>
<div class="line">                     (get_value(ft_dlclst_last(ps-&gt;X))</div>
<div class="line">top of A    6 (0) &lt; first node in the respective dlclst &gt; (0) 2 top of A</div>
<div class="line">top_1 of A  4 (1)                                         (1) 7 top_1 of A</div>
<div class="line">            0 (2)                                         (2) 3</div>
<div class="line">bot_1 of A  5 (3)                                         (3) 8 bot_1 of A</div>
<div class="line">bottom of A 9 (4) &lt;  last node in the respective dlclst &gt; (4) 1 bottom of A</div>
<div class="line">                         (get_value(ps-&gt;X))</div>
<div class="line">                                                                            .</div>
<div class="line">NOTE: Values in parenthesis are the respective element-&gt;pos_in_stack.</div>
<div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
</div><!-- fragment --><p> Eventually, the final state after sorting is shown in the following image: </p><div class="fragment"><div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
<div class="line">         stack A                                         stack B</div>
<div class="line">                     (get_value(ft_dlclst_last(ps-&gt;a))</div>
<div class="line">top of A    0 (0) &lt; first node in the respective dlclst &gt;&gt;&gt;</div>
<div class="line">top_1 of A  1 (1)</div>
<div class="line">            2 (2)</div>
<div class="line">            3 (3)</div>
<div class="line">            4 (4)</div>
<div class="line">            5 (5)</div>
<div class="line">            6 (6)</div>
<div class="line">            7 (7)</div>
<div class="line">bot_1 of A  8 (8)</div>
<div class="line">bottom of A 9 (9) &lt; last node in the respective dlclst &gt;&gt;&gt; </div>
<div class="line">                         (get_value(ps-&gt;a))</div>
<div class="line">                                                                            .</div>
<div class="line">NOTE: Values in parenthesis are the respective element-&gt;pos_in_stack.</div>
<div class="line">                                                                            .</div>
<div class="line">                                                                            .</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md6"></a>
The sorting algorithm</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Introduction</h2>
<p >A careful reading of the subject makes it obvious that the only optimization is regarding the number of ps_lang instructions that must be used to sort the numbers. That is, whatever it takes to achieve that is not only legitimate but neccesary.</p>
<p >In this line, the approach taken is to "cheat" by ordering the list first with some classical-don't-care-how-efficient algorithm and, using its results, statistical analysis, etc. find out the minimum number of ps_lang instructions to get to the same results.</p>
<p >The following stages of the sorting process can be explicitly followed in <a class="el" href="ps__sort_8h.html#ad22566f770c72ada8c2d2e1b01b93edb" title="ps_sort – The entry point for the sorting algorithm.">ps_sort()</a> function:</p><ul>
<li>Sorting preparations</li>
<li>Pre sorting</li>
<li>Cost-based pushing</li>
<li>Rotate stack A until sorted</li>
</ul>
<h3><a class="anchor" id="autotoc_md8"></a>
Sorting preparations</h3>
<p >Once every number passed is placed in the stack A, this stack is copied to an array of integer to be sorted by some classical sorting algorithm (bubble sorting in this case, this could be improved in the future). The purpose of this step is to attach (as a meta-data) to every element in stack A the position it will have once sorted. This pos_when_sorted is the key to the next stage of the sorting process.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Pre sorting</h3>
<p ><b>Pre sorting</b> is the process to smartly push to stack B every element in stack A but three. The elements in stack A are processed block-by-block and the criteria for pushing to stack B depends on the avg_pos_when_sorted of the elements still in stack A. Both the block size (half of the remaining elements in stack A to be pushed, plus one) and the avg_pos_when_sorted is re-calculated at the begining of every block processing.</p>
<p >For each block of elements to be pushed from A to B, the top A element, the next-to-top A element, the bottom A element, and the next_to_bottom A element are examined and the first one which its pos_when_sorted is smaller than the current avg_pos_when_sorted is pushed to B. If none passes this test, a ra is performed to try again. This goes on until the number o elements pushed to B equals the target block size, then, the next block is processed and so on until only three elementes are left in stack A. When this is achieved, the three remaining elements in A are sorted. These will serve as the first references for the next stage, where the elements in stack B are pushed back to A according to movement costs analysis.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Cost-based pushing</h3>
<p ><b>Cost-based pushing</b> is the stage of the sorting process where stack B is emptied by using a sequence of ps_lang instructions (which may affect both stacks) ending, of course, with a final pa.</p>
<p >Cost-based pushing is a loop that only breaks when stack B is empty, in this loop the following is performed:</p><ul>
<li>Set positions in stack to every element in both stack A and B. This is the relative position each element has in the stack it is in.</li>
<li><p class="startli">Set costs values for EACH element in stack B.</p><ul>
<li>There are two components for cost value: cost_a and cost_b. The reason there are two is because, for the current element in stack B being evaluated, the costs in rotational movements must be calculated for both stacks:<ul>
<li>From the stack B perspective, how many rotations IN THE BEST DIRECTION are needed to get the current element in stack B being evaluated to the top position so it can be pushable to stack A.</li>
<li>From the stack A perspective, how many rotations IN THE BEST DIRECTION are needed to put it in a state where pushing the top element in stack B (the one that is currently being analyzed) makes it land in the best position sorting-wise.</li>
</ul>
</li>
<li>For both cost_a and cost_b the following convention is adopted: a positive value means that rotations are performed in the "next" direction while a negative value means that rotations are performed in the "prev" direction.</li>
<li>The total_cost for the current element in stack B being analyzed depends on the absolute values of cost_a and cost_b and their signs as follows:<ul>
<li>If cost_a and cost_b have the <b>same sign</b>, this implies that simultaneous rotations on both stacks <b>MAY</b> be performed. In this case, the total_cost is the sum of:<ul>
<li>The absolute value of the difference of cost_a and cost_b. This is the number of the common rotations in the same direction for both stacks, plus</li>
<li>The remaining number of rotations of just one of the stacks, that is, the absolute value of the biggest between cost_a and cost_b, minus the former value (the common rotations).</li>
</ul>
</li>
<li>If cost_a and cost_b have <b>different signs</b>, this implies that simultaneous rotations on both stacks <b>MAY NOT</b> be performed. In this case, the total_cost is the sum of the absolute values of cost_a and cost_b, since the program must rotate in different directions each stack to get the stack A in the sweet spot and the current element in stack B being analyzed at the top of stack B to make it pushable to A.</li>
</ul>
</li>
</ul>
<p class="startli">cost problem can be seen from two perspectives:</p><ul>
<li>Taking the current state of stack A as fixed, how many rotations in the best direction must be performed in stack B to place at top B the best candidate to be pushed to stack A (at its fixed state). The cost_b value represents just that, using this convention: a positive value is in the "next" direction; a negative value is in the "prev" direction.</li>
<li>Taking the current state of stack B as fixed, how many rotations in the best direction must be performed in stack A to leave it in a state where pushing the (fixed) top B element is the correct choice. The cost_a value represents just that, using this convention: a positive value is in the "next" direction; a negative value is in the "prev" direction.</li>
</ul>
</li>
</ul>
<p >The total_cost depends on both the cost_a and cost_b values in this way:</p>
<ul>
<li>cost_a: The minimum number of rotation instructions on stack A to put it in the optimum condition to push the current top B in the right place. CHECK THIS! TODO!!!!!!!!!!!!!!!!!!!</li>
<li>cost_b: CHECK THIS! TODO!!!!!!!!!!!!!!!!!!!</li>
</ul>
<p >Find the lowest cost among the elements in stack B.</p><ul>
<li>The total cost for each element is the sum of cost_a and cost_b. The element that currently has the lowest cost is the one that will be pushed to A. Of course, there's a lot to do before actually pa'ing...</li>
</ul>
<p >Rotate before pa: This is the sequence of rotations needed before calling the pa instructions. That is, the rotations needed to:</p><ul>
<li>Place the desired (lowest cost) element in stack B in the top of the stack.</li>
<li>Reorder stack A so that when pa'ing the desired element in stack B lands in the desired position (sorted) in stack A.</li>
</ul>
<p >Finally, a pa to push the right element in stack B to the right position in stack A.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Rotate stack A until sorted</h3>
<p >As the result of Cost-based pushing, Stack B is empty and the elements in Stack A are ONLY CIRCULARLY sorted. In this final stage the stack A is rotated in the best direction to get it LINEARLY sorted. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
